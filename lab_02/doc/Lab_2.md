# Лабораторная работа №2

### Структуры данных и динамическое программирование    
                                                                                        Выполнил студент:       Шаймуханов Тимур
                                                                                                          4 курс, z34434, 2023 г
---
## Цель 

&ensp; Познакомить студента с основами структур данных и методикам динамического
программирования.

## Задание

&ensp; Поиск оптимального (кратчайшего, быстрейшего или самого дешевого) пути,
проходящего через промежуточный пункты по одному разу и возвращающегося в
исходную точку. К примеру, нахождение наиболее выгодного маршрута, позволяющего
коммивояжеру посетить со своим товаром определенные города по одному разу и
вернуться обратно. Мерой выгодности маршрута может быть минимальная длина
пути.

&ensp; Задать перечень точек с координатами X и Y. Пример:

- Точка 1, X1, Y1

- Точка 2, X2, Y2

- Точка 3, X3, Y3

- Точка ...
  
&ensp; В качестве отправной и конечной точки брать первую введенную точку.

1. Спроектировать оптимальную структуру для решения задачи с точки зрения
затрат памяти. Реализовать на языке C++ или Python

2. Спроектировать оптимальный алгоритм решения задачи с использованием
технологий динамического программирования. Оценить выислительные и
емкостные затраты. Реализовать на языке C++ или Python

## Решение

### Выбор структуры данных и алгоритма
&ensp; Воспользуемся идеей динамики по подмножествам. Это поможет нам избежать факториальной асимптотической сложности. Будем сохранять данные о длине путей, которые мы уже рассматривали. Для этого нужно как-то запоминать траекторию - то есть хранить информацию о том, через какие вершины каждый рассмотренный путь проходит. Интуитивно понятный вариант - создать массив размера $n$ по следующему правилу: $vis[i] = 1 \Leftrightarrow$ вершина $i$ посещена, $vis[i] = 0 \Leftrightarrow$ не посещена. 

&ensp; Однако удобнее и гораздо экономичнее по памяти будет хранить такой массив в ```int```, используя побитовые операции для получения и установки значений конкретных бит. Также нам нужно знать следующую вершину, поэтому получается двумерный массив размера $n \cdot 2^n$. В значения этого массива положим протяженности соответсвующих путей: ```h[mask][node]``` = длина пути, проходящего через вершины, отраженные в ```mask``` и заканчивающегося в вершине ```node```. При этом ```node``` в ```mask``` не содержится. Еще нам придется вычислить веса ребер (расстояния между точками), чтобы считать длину пути. 

&ensp; В принципе, можно каждый раз вычислять длину нужного ребра, но раз дополнительная память у нас все равно экспоненциальная, я решил посчитать их в самом начале и записать в массив $n \times n$. Помимо этого из подготовительной работы нужно считать ввод и положить все значения массива ```h``` очень большими (я взял ```MAX_INT```), чтобы потом оптимизировать. Дальнейшая логика прописана в комментариях в коде на ```C++```:

#### Реализация алгоритма

   ```C++
      h[0][0] = 0;       // стартуем нулевой вершины
      double best = INF; // сюда будем собирать ответ
  
      for (int mask = 0; mask < (1 << n); mask++) // перебираем маски
      {
          for (int u = 0; u < n; u++) // перебираем конечные точки
          {
              if (h[mask][u] != INF) // идем только туда, где еще не были - здесь мы и отходим от факториальной сложности
              {
                  int new_mask = mask | (1 << u); // перебираем кандидатов, для этого обновляем траекторию в new_mask,
                                                  // записывая посещение вершины u
  
                  for (int v = 0; v < n; v++) // перебираем кандидатов на следующий шаг
                  {
                      double w = dist_matrix[u][v]; // записываем вес следующего шага
   
                      // если нашли более оптимальный путь к вершине v, переписываем значение в h
                      if (!((new_mask >> v) & 1)) // смотрим только туда, где еще не были
                      {
                          if (h[mask][u] + w < h[new_mask][v]) 
                          {
                              h[new_mask][v] = h[mask][u] + w;
                          }
                      }
   
                      // если посетили всех и вернулись в начало дешевле, чем умели раньше, обновляем ответ
                      if ((v == 0) && (new_mask == (1 << n) - 1) && (h[mask][u] + w < best)) 
                      {
                          best = h[mask][u] + w;
                      }
                  }
              }
          }
      }

   ```
#### Оценка сложности
&ensp; Из описанного выше, затраты дополнительной памяти оцениваются как $O(n 2^n)$ - большая часть уходит на запоминание весов, конечно. С точки зрения временной сложности имеем следующее: 
  - внешний цикл по ```mask``` ~ $2^n$
  - вложенный в него по ```u``` ~ $n$
  - внутренний по ```v``` ~ $n$
Итого, имеем сложность $O(n^2 2^n)$. 

### Результат

``` console
  Enter number of points: 5
  
  point #1  1.24 7.11
  point #2  0.45 2.45
  point #3  2.28 8.41
  point #4  7.62 5.59
  point #5  2.12 3.22
  ----------
  best = 20.25  
```

## Вывод
&ensp; Я познакомился с концепцией динамического программирования. Мама ругается и говорит, что лучше бы я знакомился с девочками.
