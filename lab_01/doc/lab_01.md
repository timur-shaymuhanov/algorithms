# Лабораторная работа №1

### Алгоритмы сортировки
                                                                                        Выполнил студент:       Шаймуханов Тимур
                                                                                                          4 курс, z34434, 2023 г
---
## Цель 

Познакомить студента с основами анализа алгоритмов на примере операций
сортировки.

## Задания

### 1. Алгоритм сотрировки 1
 1.1. Сформулировать задачу, для которой требуется применение алгоритма сортировки.
 
 1.2. Выбрать алгоритм сортировки. Доказать, что выбранный алгоритм является наилучшим выбором. Привести расчет ёмкостных и вычислительных затрат.
 
 1.3. Реализовать алгоритм на языке C++.

### Решение
  
#### Постановка задачи:
Интернет-магазин VTB_MINI_STORE хочет скорить клиентов по некоторому рейтингу для дальнейшего построения индивидуальной программы лояльности для каждого пользователя. На вход подается массив ```std::vector<User>``` объектов класса ```User```, содержащего поля ```std::string name``` и ```int score``` -- имя и рейтинг пользователя, соответственно. Нужно отсортировать данный массив по значениям ```score``` (по возрастанию) и вывести результат. 

#### Выбор и оценка алгоритма
Оптимальным будет использование быстрой сортировки с выбором опорного элемента по схеме Хоара. 

#### Реализация алгоритма

```C++
  void quick_sort(vector<User> &a, int first, int last)
  {
  
      int i = first, j = last;
      User x = a[(first + last) / 2];
  
      do
      {
          while (a[i].GetScore() < x.GetScore())
              i++;
          while (a[j].GetScore() > x.GetScore())
              j--;
  
          if (i <= j)
          {
              if (i < j)
              {
                  User tmp = a[i];
                  a[i] = a[j];
                  a[j] = tmp;
              }
              i++;
              j--;
          }
      } while (i <= j);
  
      if (i < last)
          quick_sort(a, i, last);
      if (first < j)
          quick_sort(a, first, j);
  }
```
### Результат

  ``` console
  Input:            |   Output:
  _____________________________________
  
  Ibrahim:    239   |   Olga:         4
  Peter:      239   |   Paul:        24
  Fatima:     130   |   Hassan:      29
  Aleksandr:   86   |   Ling:        32
  Richard:    753   |   Aleksandr:   86
  Xin:        212   |   Ping:       107
  Bin:        270   |   Fatima:     130
  Paul:        24   |   Ming:       148
  Ping:       107   |   Sergey:     154
  Lin:        826   |   Martin:     170
  Olga:         4   |   William:    172
  Sri:        923   |   Xin:        212
  Pedro:      362   |   Samuel:     229
  William:    172   |   Ibrahim:    239
  Rosa:       256   |   Peter:      239
  Thomas:     482   |   Rosa:       256
  Jorge:      677   |   Bin:        270
  Yong:       640   |   Victor:     285
  Elizabeth:  907   |   Siti:       335
  Sergey:     154   |   Pedro:      362
  Ram:        375   |   Ram:        375
  Hassan:      29   |   Sarah:      417
  Anita:      765   |   Emmanuel:   432
  Manuel:     458   |   Manuel:     458
  Victor:     285   |   Mario:      459
  Sandra:     475   |   Sandra:     475
  Ming:       148   |   Thomas:     482
  Siti:       335   |   Miguel:     541
  Miguel:     541   |   Rita:       615
  Emmanuel:   432   |   Yong:       640
  Samuel:     229   |   Jorge:      677
  Ling:        32   |   Richard:    753
  Charles:    904   |   Anita:      765
  Sarah:      417   |   Lin:        826
  Mario:      459   |   Joao:       864
  Joao:       864   |   Svetlana:   897
  Tatyana:    962   |   Charles:    904
  Mark:       951   |   Elizabeth:  907
  Rita:       615   |   Sri:        923
  Martin:     170   |   Mark:       951
  Svetlana:   897   |   Tatyana:    962
```

### 2. Алгоритм сотрировки 2
  2.1. Сформулировать задачу, для которой требуется применение алгоритма сортировки. Алгоритм сортировки 2 должен отличаться от алгоритма сортировки 1 Асимтотическая сложность алгоритма 2 должна быть больше, чем у алгоритма 1
  
  2.2. Выбрать алгоритм сортировки. Доказать, что выбранный алгоритм является наилучшим выбором. Привести расчет ёмкостных и вычислительных затрат.
 
  2.3. Реализовать алгоритм на языке C++.

### Решение

#### Постановка задачи
После проведения экономического исследования стало ясно, что работать с каждым пользователем отдельно нецелесообразно, так как это слишком дорого. Было принято решение разделить пользователей на 10 уровней лояльности и составлять акционные предложения для каждого уровня. Для этого нужно отсортировать пользователей по возрастанию уровня лояльности. Вход и выход аналогичны предыдущему пункту, только теперь значение поля ```score``` могут быть от 0 до 9.
    
#### Выбор и оценка алгоритма
В данной постановке задачи целесообразно использовать сортировку подстчетом, так как мы заранее знаем, что количество $M$ различных элементов (уровней лояльности) значительно меньше количества сортируемых - $N$. Используя это, мы можем реализовать алгоритм, работающий за $O(N)$ по времени и $O(N)$ по дополнительной памяти. Вообще, для сортировки массива чисел потребовалось бы только $O(M)$ дополнительной памяти, но так как в нашей постановке задачи приходится сохранять не только рейтинг, но и имя, нужно $O(N)$. Время линейное, так как мы проходимся по входным данным, выполняя частотный анализ один раз для группировки пользователей по рейтингу. При этом получаем структуру также из $N$ элементов, по которой потом проходимся один раз для "развертывания" в одномерный вектор выходных данных. Дополнительная память при этом затрачивается на сгрупированную и развернутую формы, в каждой из которых по $N$ элементов.  

#### Реализация алгоритма

```C++
  vector<User> countable_sort(vector<User> data, int num_of_levels)
  {
      vector<User> freq[num_of_levels];
      vector<User> sorted_data;
  
      for (User user : data)
      {
          freq[user.GetScore()].push_back(user);
      }
  
      for (vector<User> vec : freq)
      {
          for (User user : vec)
          {
              sorted_data.push_back(user);
          }
      }
      return sorted_data;
  };
```
### Результат

```console
  Input:            |   Output:
  _____________________________________
  
  Ibrahim:      4   |   Xin:          0
  Peter:        7   |   Sergey:       0
  Fatima:       2   |   Anita:        0
  Aleksandr:    6   |   Samuel:       0
  Richard:      9   |   Joao:         0
  Xin:          0   |   Rosa:         1
  Bin:          8   |   Jorge:        1
  Paul:         8   |   Victor:       1
  Ping:         6   |   Ling:         1
  Lin:          8   |   Fatima:       2
  Olga:         2   |   Olga:         2
  Sri:          4   |   Siti:         2
  Pedro:        5   |   Sarah:        2
  William:      7   |   Thomas:       3
  Rosa:         1   |   Elizabeth:    3
  Thomas:       3   |   Ming:         3
  Jorge:        1   |   Mario:        3
  Yong:         8   |   Tatyana:      3
  Elizabeth:    3   |   Ibrahim:      4
  Sergey:       0   |   Sri:          4
  Ram:          7   |   Charles:      4
  Hassan:       9   |   Martin:       4
  Anita:        0   |   Pedro:        5
  Manuel:       8   |   Emmanuel:     5
  Victor:       1   |   Aleksandr:    6
  Sandra:       7   |   Ping:         6
  Ming:         3   |   Mark:         6
  Siti:         2   |   Peter:        7
  Miguel:       7   |   William:      7
  Emmanuel:     5   |   Ram:          7
  Samuel:       0   |   Sandra:       7
  Ling:         1   |   Miguel:       7
  Charles:      4   |   Bin:          8
  Sarah:        2   |   Paul:         8
  Mario:        3   |   Lin:          8
  Joao:         0   |   Yong:         8
  Tatyana:      3   |   Manuel:       8
  Mark:         6   |   Richard:      9
  Rita:         9   |   Hassan:       9
  Martin:       4   |   Rita:         9
  Svetlana:     9   |   Svetlana:     9
```

## Вывод
Я познакомился с алгоритмами сортивки и способами оценки их эффективности (по времени и по памяти) в терминологии $О$-символики, вспомнил, как работать с классами и шаблоном ```vector<t>``` в C++. В обоих случаях были реализованы устойчивые сортировки.
