# Лабораторная работа №1

### Алгоритмы сортировки
                                                                                        Выполнил студент:       Шаймуханов Тимур
                                                                                                          4 курс, z34434, 2023 г
---
## Цель 

Познакомить студента с основами анализа алгоритмов на примере операций
сортировки.

## Задания

### 1. Алгоритм сотрировки 1
 1.1. Сформулировать задачу, для которой требуется применение алгоритма сортировки.
 
 1.2. Выбрать алгоритм сортировки. Доказать, что выбранный алгоритм является наилучшим выбором. Привести расчет ёмкостных и вычислительных затрат.
 
 1.3. Реализовать алгоритм на языке C++.

### Решение
  
#### Постановка задачи:
Интернет-магазин VTB_MINI_STORE хочет скорить клиентов по некоторому рейтингу для дальнейшего построения индивидуальной программы лояльности для каждого пользователя. На вход подается массив ```std::vector<User>``` объектов класса ```User```, содержащего поля ```std::string name``` и ```int score``` -- имя и рейтинг пользователя, соответственно. Нужно отсортировать данный массив по значениям ```score``` (по возрастанию) и вывести результат. 

#### Выбор и оценка алгоритма

Оптимальным будет использование быстрой сортировки по схеме Хоара. Сортировку мы производим внутри массива, поэтому дополнительная память $O(1)$ - на несколько переменных. Что касается временной сложности:

$T(n) = O(n) + T(\alpha * n) + T((1 — \alpha) * n)$ -- $O(n)$ затрачивается на перестановку на конкретной итерации и мы вызываем для двух частей, за распределение которых отвечает параметр $\alpha$.

В лучшем случае $a = \frac{1}{2}$, то есть опорный элемент каждый раз делит участок на две равные части. Тогда: 
$T(n) = n + 2 * T(\frac{n}{2}) = n + 2 * (\frac{n}{2} + 2 * T(\frac{n}{4})) = n + n + 4 * T(\frac{n}{4}) = ... = n \cdot log(n)$ Итого будет log(n) слагаемых, потому как слагаемые появляются до тех пор, пока аргумент не уменьшится до 1. Итого $T(n) = O(n \cdot log(n))$.

В худшем случае $a = \frac{1}{n}$, то есть опорный отсекает ровно один элемент. Тогда: 

$T(n) =n + O(1) + T(n — 1) (n — 1) = n + O(1) + (n — 1 + O(1) + T(n — 2)) = ... = O(n^2)$. Аргумент в $T$ уменьшается до единицы за $n$ шагов, поэтому в итоге старший член будет квадратичным по $n$.

#### Реализация алгоритма

```C++
  void quick_sort(vector<User> &a, int first, int last)
  {
  
      int i = first, j = last;
      User x = a[(first + last) / 2];
  
      do
      {
          while (a[i].GetScore() < x.GetScore())
              i++;
          while (a[j].GetScore() > x.GetScore())
              j--;
  
          if (i <= j)
          {
              if (i < j)
              {
                  User tmp = a[i];
                  a[i] = a[j];
                  a[j] = tmp;
              }
              i++;
              j--;
          }
      } while (i <= j);
  
      if (i < last)
          quick_sort(a, i, last);
      if (first < j)
          quick_sort(a, first, j);
  }
```
### Результат

  ``` console
Input:            |   Output:
_____________________________________

Ibrahim:    239   |   Mark:        84
Peter:      239   |   Richard:    195
Fatima:     800   |   Victor:     212
Aleksandr:  869   |   Sergey:     227
Richard:    195   |   Peter:      239
Xin:        654   |   Ibrahim:    239
Bin:        560   |   Charles:    275
Paul:       499   |   Ming:       297
Ping:       333   |   Manuel:     305
Lin:        727   |   Sandra:     327
Olga:       459   |   Ping:       333
Sri:        792   |   Anita:      344
Pedro:      557   |   Hassan:     405
William:    920   |   Ling:       424
Rosa:       866   |   Ram:        428
Thomas:     706   |   Joao:       433
Jorge:      929   |   Sarah:      436
Yong:       826   |   Olga:       459
Elizabeth:  672   |   Rita:       486
Sergey:     227   |   Paul:       499
Ram:        428   |   Tatyana:    549
Hassan:     405   |   Pedro:      557
Anita:      344   |   Bin:        560
Manuel:     305   |   Mario:      598
Victor:     212   |   Emmanuel:   632
Sandra:     327   |   Samuel:     645
Ming:       297   |   Miguel:     650
Siti:       870   |   Xin:        654
Miguel:     650   |   Elizabeth:  672
Emmanuel:   632   |   Thomas:     706
Samuel:     645   |   Lin:        727
Ling:       424   |   Martin:     740
Charles:    275   |   Sri:        792
Sarah:      436   |   Fatima:     800
Mario:      598   |   Yong:       826
Joao:       433   |   Rosa:       866
Tatyana:    549   |   Aleksandr:  869
Mark:        84   |   Siti:       870
Rita:       486   |   William:    920
Martin:     740   |   Jorge:      929
Svetlana:   968   |   Svetlana:   968
```

### 2. Алгоритм сотрировки 2
  2.1. Сформулировать задачу, для которой требуется применение алгоритма сортировки. Алгоритм сортировки 2 должен отличаться от алгоритма сортировки 1 Асимтотическая сложность алгоритма 2 должна быть больше, чем у алгоритма 1
  
  2.2. Выбрать алгоритм сортировки. Доказать, что выбранный алгоритм является наилучшим выбором. Привести расчет ёмкостных и вычислительных затрат.
 
  2.3. Реализовать алгоритм на языке C++.

### Решение

#### Постановка задачи
После проведения экономического исследования стало ясно, что работать с каждым пользователем отдельно нецелесообразно, так как это слишком дорого. Было принято решение разделить пользователей на 10 уровней лояльности и составлять акционные предложения для каждого уровня. Для этого нужно отсортировать пользователей по возрастанию уровня лояльности. Вход и выход аналогичны предыдущему пункту, только теперь значение поля ```score``` могут быть от 0 до 9.
    
#### Выбор и оценка алгоритма
В данной постановке задачи целесообразно использовать сортировку подстчетом, так как мы заранее знаем, что количество $M$ различных элементов (уровней лояльности) значительно меньше количества сортируемых - $N$. Используя это, мы можем реализовать алгоритм, работающий за $O(N)$ по времени и $O(N)$ по дополнительной памяти. Вообще, для сортировки массива чисел потребовалось бы только $O(M)$ дополнительной памяти, но так как в нашей постановке задачи приходится сохранять не только рейтинг, но и имя, нужно $O(N)$. Время линейное, так как мы проходимся по входным данным, выполняя частотный анализ один раз для группировки пользователей по рейтингу. При этом получаем структуру также из $N$ элементов, по которой потом проходимся один раз для "развертывания" в одномерный вектор выходных данных. Дополнительная память при этом затрачивается на сгрупированную и развернутую формы, в каждой из которых по $N$ элементов.  

#### Реализация алгоритма

```C++
  vector<User> countable_sort(vector<User> data, int num_of_levels)
  {
      vector<User> freq[num_of_levels];
      vector<User> sorted_data;
  
      for (User user : data)
      {
          freq[user.GetScore()].push_back(user);
      }
  
      for (vector<User> vec : freq)
      {
          for (User user : vec)
          {
              sorted_data.push_back(user);
          }
      }
      return sorted_data;
  };
```
### Результат

```console
  Input:            |   Output:
  _____________________________________
  
  Ibrahim:      4   |   Xin:          0
  Peter:        7   |   Sergey:       0
  Fatima:       2   |   Anita:        0
  Aleksandr:    6   |   Samuel:       0
  Richard:      9   |   Joao:         0
  Xin:          0   |   Rosa:         1
  Bin:          8   |   Jorge:        1
  Paul:         8   |   Victor:       1
  Ping:         6   |   Ling:         1
  Lin:          8   |   Fatima:       2
  Olga:         2   |   Olga:         2
  Sri:          4   |   Siti:         2
  Pedro:        5   |   Sarah:        2
  William:      7   |   Thomas:       3
  Rosa:         1   |   Elizabeth:    3
  Thomas:       3   |   Ming:         3
  Jorge:        1   |   Mario:        3
  Yong:         8   |   Tatyana:      3
  Elizabeth:    3   |   Ibrahim:      4
  Sergey:       0   |   Sri:          4
  Ram:          7   |   Charles:      4
  Hassan:       9   |   Martin:       4
  Anita:        0   |   Pedro:        5
  Manuel:       8   |   Emmanuel:     5
  Victor:       1   |   Aleksandr:    6
  Sandra:       7   |   Ping:         6
  Ming:         3   |   Mark:         6
  Siti:         2   |   Peter:        7
  Miguel:       7   |   William:      7
  Emmanuel:     5   |   Ram:          7
  Samuel:       0   |   Sandra:       7
  Ling:         1   |   Miguel:       7
  Charles:      4   |   Bin:          8
  Sarah:        2   |   Paul:         8
  Mario:        3   |   Lin:          8
  Joao:         0   |   Yong:         8
  Tatyana:      3   |   Manuel:       8
  Mark:         6   |   Richard:      9
  Rita:         9   |   Hassan:       9
  Martin:       4   |   Rita:         9
  Svetlana:     9   |   Svetlana:     9
```

## Вывод
Я познакомился с алгоритмами сортивки и способами оценки их эффективности (по времени и по памяти) в терминологии $О$-символики, вспомнил, как работать с классами и шаблоном ```vector<t>``` в C++. 
